#include <bits/stdc++.h>

using namespace std;
vector<int> nv;

void print(){
    for(auto n:nv) cout<<n<<"\t";
    cout<<"\n";
}
/*
void f(int n, int r, int depth){
    if(depth==r){
        print();
        return;
    }
    for(int i=depth;i<n;i++){
        swap(nv[i],nv[depth]);
        f(n,r,depth+1);
        swap(nv[i],nv[depth]);
    }
}
int main(){
    for(int i=1;i<=4;i++)   nv.push_back(i);
    f(4,4,0);
}

*/
/*
고정 개념 구현 설명
스왑을 통한 고정:
swap(nv[i], nv[depth]);가 고정의 핵심 부분입니다. 여기서:
depth는 고정할 위치를 나타내고,
i는 현재 루프에서 지정된 위치를 나타냅니다.
이 스왑을 통해 depth 위치에 있는 요소가 현재 루프에서 선택된 요소로 바뀌게 됩니다. 즉, depth를 고정한 채 그 위치에 새로운 값을 넣는 것입니다.
예시:

만약 nv가 [1, 2, 3, 4]이고 현재 depth가 0인 상태에서 시작한다고 가정합시다.
루프가 실행되면:
첫 번째 Iteration (i=0):
swap(nv[0], nv[0]); (변화 없음, 고정: [1, 2, 3, 4])
두 번째 Iteration (i=1):
swap(nv[1], nv[0]); (고정: [2, 1, 3, 4])
세 번째 Iteration (i=2):
swap(nv[2], nv[0]); (고정: [3, 2, 1, 4])
네 번째 Iteration (i=3):
swap(nv[3], nv[0]); (고정: [4, 2, 3, 1])
각 스왑 후 재귀 호출을 통해 다음 깊이로 들어가면서 나머지 요소들에 대한 순열을 계속 생성합니다.

재귀 호출로 깊이 증가:

f(n, r, depth + 1);는 현재 고정된 요소를 바탕으로 다음 깊이로 넘어가, 남은 요소들로 새롭게 순열을 생성할 수 있게 합니다. 고정된 요소는 여기서 바뀌지 않으므로 그 자리는 예약된 상태로 남습니다.
원래 상태로 되돌리기:

swap(nv[i], nv[depth]);가 호출된 후 다시 한번 수행돼 원래 상태로 복원합니다. 이것은 다음 루프에서 새로운 고정을 시도할 수 있도록 배열을 초기 상태로 되돌려주는 것입니다. 이렇게 함으로써 각 요소에 대해 모든 가능한 고정 위치를 시도할 수 있습니다.
요약
고정은 스왑 명령어를 통해 이루어지고, 그 요소가 선택된 후 다음 호출에서는 고정된 요소는 바뀌지 않으며, 나머지 요소들로 새로운 조합을 만들어 나가는 방식으로 구현됩니다. 재귀 호출을 통해 각 상황에서의 조합을 다 탐색하고, 끝나는 시점에 다시 원래 형태로 되돌림으로써 다음 조합을 시도합니다. 이 방법으로 모든 가능한 순열을 생성하게 됩니다.
*/